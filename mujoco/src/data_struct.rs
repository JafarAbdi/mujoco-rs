//! Auto-generated Data accessor functions
//! Generated by generate_from_introspect.py - DO NOT EDIT MANUALLY

use crate::Data;
use mujoco_sys::{mjContact, mjSolverStat, mjTimerStat, mjWarningStat, mjtNum, mjtSize};

#[allow(non_snake_case)]
impl<'a> Data<'a> {
    pub fn narena(&self) -> mjtSize {
        self.raw().narena
    }
    pub fn nbuffer(&self) -> mjtSize {
        self.raw().nbuffer
    }
    pub fn nplugin(&self) -> usize {
        self.raw().nplugin as usize
    }
    pub fn pstack(&self) -> usize {
        self.raw().pstack as usize
    }
    pub fn pbase(&self) -> usize {
        self.raw().pbase as usize
    }
    pub fn parena(&self) -> usize {
        self.raw().parena as usize
    }
    pub fn maxuse_stack(&self) -> mjtSize {
        self.raw().maxuse_stack
    }
    pub fn maxuse_threadstack(&self) -> &[mjtSize; 128] {
        &self.raw().maxuse_threadstack
    }
    pub fn maxuse_arena(&self) -> mjtSize {
        self.raw().maxuse_arena
    }
    pub fn maxuse_con(&self) -> usize {
        self.raw().maxuse_con as usize
    }
    pub fn maxuse_efc(&self) -> usize {
        self.raw().maxuse_efc as usize
    }
    pub fn solver(&self) -> &[mjSolverStat; 4000] {
        &self.raw().solver
    }
    pub fn solver_niter(&self) -> &[i32; 20] {
        &self.raw().solver_niter
    }
    pub fn solver_nnz(&self) -> &[i32; 20] {
        &self.raw().solver_nnz
    }
    pub fn solver_fwdinv(&self) -> &[mjtNum; 2] {
        &self.raw().solver_fwdinv
    }
    pub fn warning(&self) -> &[mjWarningStat; 8] {
        &self.raw().warning
    }
    pub fn timer(&self) -> &[mjTimerStat; 15] {
        &self.raw().timer
    }
    pub fn ncon(&self) -> usize {
        self.raw().ncon as usize
    }
    pub fn ne(&self) -> usize {
        self.raw().ne as usize
    }
    pub fn nf(&self) -> usize {
        self.raw().nf as usize
    }
    pub fn nl(&self) -> usize {
        self.raw().nl as usize
    }
    pub fn nefc(&self) -> usize {
        self.raw().nefc as usize
    }
    pub fn nJ(&self) -> usize {
        self.raw().nJ as usize
    }
    pub fn nA(&self) -> usize {
        self.raw().nA as usize
    }
    pub fn nisland(&self) -> usize {
        self.raw().nisland as usize
    }
    pub fn nidof(&self) -> usize {
        self.raw().nidof as usize
    }
    pub fn time(&self) -> mjtNum {
        self.raw().time
    }
    pub fn energy(&self) -> &[mjtNum; 2] {
        &self.raw().energy
    }

    /// position
    pub fn qpos(&self) -> &[mjtNum] {
        assert!(!self.raw().qpos.is_null(), "Pointer qpos is null");
        unsafe { std::slice::from_raw_parts(self.raw().qpos, self.model.nq()) }
    }

    /// position
    pub fn qpos_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().qpos.is_null(), "Pointer qpos is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qpos, self.model.nq()) }
    }

    /// velocity
    pub fn qvel(&self) -> &[mjtNum] {
        assert!(!self.raw().qvel.is_null(), "Pointer qvel is null");
        unsafe { std::slice::from_raw_parts(self.raw().qvel, self.model.nv()) }
    }

    /// velocity
    pub fn qvel_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().qvel.is_null(), "Pointer qvel is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qvel, self.model.nv()) }
    }

    /// actuator activation
    pub fn act(&self) -> &[mjtNum] {
        assert!(!self.raw().act.is_null(), "Pointer act is null");
        unsafe { std::slice::from_raw_parts(self.raw().act, self.model.na()) }
    }

    /// actuator activation
    pub fn act_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().act.is_null(), "Pointer act is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().act, self.model.na()) }
    }

    /// acceleration used for warmstart
    pub fn qacc_warmstart(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qacc_warmstart.is_null(),
            "Pointer qacc_warmstart is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qacc_warmstart, self.model.nv()) }
    }

    /// acceleration used for warmstart
    pub fn qacc_warmstart_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qacc_warmstart.is_null(),
            "Pointer qacc_warmstart is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qacc_warmstart, self.model.nv()) }
    }

    /// plugin state
    pub fn plugin_state(&self) -> &[mjtNum] {
        assert!(
            !self.raw().plugin_state.is_null(),
            "Pointer plugin_state is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().plugin_state, self.model.npluginstate()) }
    }

    /// plugin state
    pub fn plugin_state_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().plugin_state.is_null(),
            "Pointer plugin_state is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().plugin_state, self.model.npluginstate())
        }
    }

    /// control
    pub fn ctrl(&self) -> &[mjtNum] {
        assert!(!self.raw().ctrl.is_null(), "Pointer ctrl is null");
        unsafe { std::slice::from_raw_parts(self.raw().ctrl, self.model.nu()) }
    }

    /// control
    pub fn ctrl_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().ctrl.is_null(), "Pointer ctrl is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().ctrl, self.model.nu()) }
    }

    /// applied generalized force
    pub fn qfrc_applied(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qfrc_applied.is_null(),
            "Pointer qfrc_applied is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qfrc_applied, self.model.nv()) }
    }

    /// applied generalized force
    pub fn qfrc_applied_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qfrc_applied.is_null(),
            "Pointer qfrc_applied is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qfrc_applied, self.model.nv()) }
    }

    /// applied Cartesian force/torque
    pub fn xfrc_applied(&self) -> &[mjtNum] {
        assert!(
            !self.raw().xfrc_applied.is_null(),
            "Pointer xfrc_applied is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().xfrc_applied, self.model.nbody() * 6) }
    }

    /// applied Cartesian force/torque
    pub fn xfrc_applied_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().xfrc_applied.is_null(),
            "Pointer xfrc_applied is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().xfrc_applied, self.model.nbody() * 6)
        }
    }

    /// enable/disable constraints
    pub fn eq_active(&self) -> &[u8] {
        assert!(!self.raw().eq_active.is_null(), "Pointer eq_active is null");
        unsafe { std::slice::from_raw_parts(self.raw().eq_active, self.model.neq()) }
    }

    /// enable/disable constraints
    pub fn eq_active_mut(&mut self) -> &mut [u8] {
        assert!(!self.raw().eq_active.is_null(), "Pointer eq_active is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().eq_active, self.model.neq()) }
    }

    /// positions of mocap bodies
    pub fn mocap_pos(&self) -> &[mjtNum] {
        assert!(!self.raw().mocap_pos.is_null(), "Pointer mocap_pos is null");
        unsafe { std::slice::from_raw_parts(self.raw().mocap_pos, self.model.nmocap() * 3) }
    }

    /// positions of mocap bodies
    pub fn mocap_pos_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().mocap_pos.is_null(), "Pointer mocap_pos is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().mocap_pos, self.model.nmocap() * 3) }
    }

    /// orientations of mocap bodies
    pub fn mocap_quat(&self) -> &[mjtNum] {
        assert!(
            !self.raw().mocap_quat.is_null(),
            "Pointer mocap_quat is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().mocap_quat, self.model.nmocap() * 4) }
    }

    /// orientations of mocap bodies
    pub fn mocap_quat_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().mocap_quat.is_null(),
            "Pointer mocap_quat is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().mocap_quat, self.model.nmocap() * 4)
        }
    }

    /// acceleration
    pub fn qacc(&self) -> &[mjtNum] {
        assert!(!self.raw().qacc.is_null(), "Pointer qacc is null");
        unsafe { std::slice::from_raw_parts(self.raw().qacc, self.model.nv()) }
    }

    /// acceleration
    pub fn qacc_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().qacc.is_null(), "Pointer qacc is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qacc, self.model.nv()) }
    }

    /// time-derivative of actuator activation
    pub fn act_dot(&self) -> &[mjtNum] {
        assert!(!self.raw().act_dot.is_null(), "Pointer act_dot is null");
        unsafe { std::slice::from_raw_parts(self.raw().act_dot, self.model.na()) }
    }

    /// time-derivative of actuator activation
    pub fn act_dot_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().act_dot.is_null(), "Pointer act_dot is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().act_dot, self.model.na()) }
    }

    /// user data, not touched by engine
    pub fn userdata(&self) -> &[mjtNum] {
        assert!(!self.raw().userdata.is_null(), "Pointer userdata is null");
        unsafe { std::slice::from_raw_parts(self.raw().userdata, self.model.nuserdata()) }
    }

    /// user data, not touched by engine
    pub fn userdata_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().userdata.is_null(), "Pointer userdata is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().userdata, self.model.nuserdata()) }
    }

    /// sensor data array
    pub fn sensordata(&self) -> &[mjtNum] {
        assert!(
            !self.raw().sensordata.is_null(),
            "Pointer sensordata is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().sensordata, self.model.nsensordata()) }
    }

    /// sensor data array
    pub fn sensordata_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().sensordata.is_null(),
            "Pointer sensordata is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().sensordata, self.model.nsensordata())
        }
    }

    /// copy of m->plugin, required for deletion
    pub fn plugin(&self) -> &[i32] {
        assert!(!self.raw().plugin.is_null(), "Pointer plugin is null");
        unsafe { std::slice::from_raw_parts(self.raw().plugin, self.model.nplugin()) }
    }

    /// copy of m->plugin, required for deletion
    pub fn plugin_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().plugin.is_null(), "Pointer plugin is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().plugin, self.model.nplugin()) }
    }

    /// pointer to plugin-managed data structure
    pub fn plugin_data(&self) -> &[usize] {
        assert!(
            !self.raw().plugin_data.is_null(),
            "Pointer plugin_data is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().plugin_data, self.model.nplugin()) }
    }

    /// pointer to plugin-managed data structure
    pub fn plugin_data_mut(&mut self) -> &mut [usize] {
        assert!(
            !self.raw().plugin_data.is_null(),
            "Pointer plugin_data is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().plugin_data, self.model.nplugin()) }
    }

    /// Cartesian position of body frame
    pub fn xpos(&self) -> &[mjtNum] {
        assert!(!self.raw().xpos.is_null(), "Pointer xpos is null");
        unsafe { std::slice::from_raw_parts(self.raw().xpos, self.model.nbody() * 3) }
    }

    /// Cartesian position of body frame
    pub fn xpos_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().xpos.is_null(), "Pointer xpos is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().xpos, self.model.nbody() * 3) }
    }

    /// Cartesian orientation of body frame
    pub fn xquat(&self) -> &[mjtNum] {
        assert!(!self.raw().xquat.is_null(), "Pointer xquat is null");
        unsafe { std::slice::from_raw_parts(self.raw().xquat, self.model.nbody() * 4) }
    }

    /// Cartesian orientation of body frame
    pub fn xquat_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().xquat.is_null(), "Pointer xquat is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().xquat, self.model.nbody() * 4) }
    }

    /// Cartesian orientation of body frame
    pub fn xmat(&self) -> &[mjtNum] {
        assert!(!self.raw().xmat.is_null(), "Pointer xmat is null");
        unsafe { std::slice::from_raw_parts(self.raw().xmat, self.model.nbody() * 9) }
    }

    /// Cartesian orientation of body frame
    pub fn xmat_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().xmat.is_null(), "Pointer xmat is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().xmat, self.model.nbody() * 9) }
    }

    /// Cartesian position of body com
    pub fn xipos(&self) -> &[mjtNum] {
        assert!(!self.raw().xipos.is_null(), "Pointer xipos is null");
        unsafe { std::slice::from_raw_parts(self.raw().xipos, self.model.nbody() * 3) }
    }

    /// Cartesian position of body com
    pub fn xipos_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().xipos.is_null(), "Pointer xipos is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().xipos, self.model.nbody() * 3) }
    }

    /// Cartesian orientation of body inertia
    pub fn ximat(&self) -> &[mjtNum] {
        assert!(!self.raw().ximat.is_null(), "Pointer ximat is null");
        unsafe { std::slice::from_raw_parts(self.raw().ximat, self.model.nbody() * 9) }
    }

    /// Cartesian orientation of body inertia
    pub fn ximat_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().ximat.is_null(), "Pointer ximat is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().ximat, self.model.nbody() * 9) }
    }

    /// Cartesian position of joint anchor
    pub fn xanchor(&self) -> &[mjtNum] {
        assert!(!self.raw().xanchor.is_null(), "Pointer xanchor is null");
        unsafe { std::slice::from_raw_parts(self.raw().xanchor, self.model.njnt() * 3) }
    }

    /// Cartesian position of joint anchor
    pub fn xanchor_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().xanchor.is_null(), "Pointer xanchor is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().xanchor, self.model.njnt() * 3) }
    }

    /// Cartesian joint axis
    pub fn xaxis(&self) -> &[mjtNum] {
        assert!(!self.raw().xaxis.is_null(), "Pointer xaxis is null");
        unsafe { std::slice::from_raw_parts(self.raw().xaxis, self.model.njnt() * 3) }
    }

    /// Cartesian joint axis
    pub fn xaxis_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().xaxis.is_null(), "Pointer xaxis is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().xaxis, self.model.njnt() * 3) }
    }

    /// Cartesian geom position
    pub fn geom_xpos(&self) -> &[mjtNum] {
        assert!(!self.raw().geom_xpos.is_null(), "Pointer geom_xpos is null");
        unsafe { std::slice::from_raw_parts(self.raw().geom_xpos, self.model.ngeom() * 3) }
    }

    /// Cartesian geom position
    pub fn geom_xpos_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().geom_xpos.is_null(), "Pointer geom_xpos is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().geom_xpos, self.model.ngeom() * 3) }
    }

    /// Cartesian geom orientation
    pub fn geom_xmat(&self) -> &[mjtNum] {
        assert!(!self.raw().geom_xmat.is_null(), "Pointer geom_xmat is null");
        unsafe { std::slice::from_raw_parts(self.raw().geom_xmat, self.model.ngeom() * 9) }
    }

    /// Cartesian geom orientation
    pub fn geom_xmat_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().geom_xmat.is_null(), "Pointer geom_xmat is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().geom_xmat, self.model.ngeom() * 9) }
    }

    /// Cartesian site position
    pub fn site_xpos(&self) -> &[mjtNum] {
        assert!(!self.raw().site_xpos.is_null(), "Pointer site_xpos is null");
        unsafe { std::slice::from_raw_parts(self.raw().site_xpos, self.model.nsite() * 3) }
    }

    /// Cartesian site position
    pub fn site_xpos_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().site_xpos.is_null(), "Pointer site_xpos is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().site_xpos, self.model.nsite() * 3) }
    }

    /// Cartesian site orientation
    pub fn site_xmat(&self) -> &[mjtNum] {
        assert!(!self.raw().site_xmat.is_null(), "Pointer site_xmat is null");
        unsafe { std::slice::from_raw_parts(self.raw().site_xmat, self.model.nsite() * 9) }
    }

    /// Cartesian site orientation
    pub fn site_xmat_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().site_xmat.is_null(), "Pointer site_xmat is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().site_xmat, self.model.nsite() * 9) }
    }

    /// Cartesian camera position
    pub fn cam_xpos(&self) -> &[mjtNum] {
        assert!(!self.raw().cam_xpos.is_null(), "Pointer cam_xpos is null");
        unsafe { std::slice::from_raw_parts(self.raw().cam_xpos, self.model.ncam() * 3) }
    }

    /// Cartesian camera position
    pub fn cam_xpos_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().cam_xpos.is_null(), "Pointer cam_xpos is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().cam_xpos, self.model.ncam() * 3) }
    }

    /// Cartesian camera orientation
    pub fn cam_xmat(&self) -> &[mjtNum] {
        assert!(!self.raw().cam_xmat.is_null(), "Pointer cam_xmat is null");
        unsafe { std::slice::from_raw_parts(self.raw().cam_xmat, self.model.ncam() * 9) }
    }

    /// Cartesian camera orientation
    pub fn cam_xmat_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().cam_xmat.is_null(), "Pointer cam_xmat is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().cam_xmat, self.model.ncam() * 9) }
    }

    /// Cartesian light position
    pub fn light_xpos(&self) -> &[mjtNum] {
        assert!(
            !self.raw().light_xpos.is_null(),
            "Pointer light_xpos is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().light_xpos, self.model.nlight() * 3) }
    }

    /// Cartesian light position
    pub fn light_xpos_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().light_xpos.is_null(),
            "Pointer light_xpos is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().light_xpos, self.model.nlight() * 3)
        }
    }

    /// Cartesian light direction
    pub fn light_xdir(&self) -> &[mjtNum] {
        assert!(
            !self.raw().light_xdir.is_null(),
            "Pointer light_xdir is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().light_xdir, self.model.nlight() * 3) }
    }

    /// Cartesian light direction
    pub fn light_xdir_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().light_xdir.is_null(),
            "Pointer light_xdir is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().light_xdir, self.model.nlight() * 3)
        }
    }

    /// center of mass of each subtree
    pub fn subtree_com(&self) -> &[mjtNum] {
        assert!(
            !self.raw().subtree_com.is_null(),
            "Pointer subtree_com is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().subtree_com, self.model.nbody() * 3) }
    }

    /// center of mass of each subtree
    pub fn subtree_com_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().subtree_com.is_null(),
            "Pointer subtree_com is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().subtree_com, self.model.nbody() * 3)
        }
    }

    /// com-based motion axis of each dof (rot:lin)
    pub fn cdof(&self) -> &[mjtNum] {
        assert!(!self.raw().cdof.is_null(), "Pointer cdof is null");
        unsafe { std::slice::from_raw_parts(self.raw().cdof, self.model.nv() * 6) }
    }

    /// com-based motion axis of each dof (rot:lin)
    pub fn cdof_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().cdof.is_null(), "Pointer cdof is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().cdof, self.model.nv() * 6) }
    }

    /// com-based body inertia and mass
    pub fn cinert(&self) -> &[mjtNum] {
        assert!(!self.raw().cinert.is_null(), "Pointer cinert is null");
        unsafe { std::slice::from_raw_parts(self.raw().cinert, self.model.nbody() * 10) }
    }

    /// com-based body inertia and mass
    pub fn cinert_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().cinert.is_null(), "Pointer cinert is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().cinert, self.model.nbody() * 10) }
    }

    /// Cartesian flex vertex positions
    pub fn flexvert_xpos(&self) -> &[mjtNum] {
        assert!(
            !self.raw().flexvert_xpos.is_null(),
            "Pointer flexvert_xpos is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().flexvert_xpos, self.model.nflexvert() * 3) }
    }

    /// Cartesian flex vertex positions
    pub fn flexvert_xpos_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().flexvert_xpos.is_null(),
            "Pointer flexvert_xpos is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().flexvert_xpos, self.model.nflexvert() * 3)
        }
    }

    /// flex element bounding boxes (center, size)
    pub fn flexelem_aabb(&self) -> &[mjtNum] {
        assert!(
            !self.raw().flexelem_aabb.is_null(),
            "Pointer flexelem_aabb is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().flexelem_aabb, self.model.nflexelem() * 6) }
    }

    /// flex element bounding boxes (center, size)
    pub fn flexelem_aabb_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().flexelem_aabb.is_null(),
            "Pointer flexelem_aabb is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().flexelem_aabb, self.model.nflexelem() * 6)
        }
    }

    /// number of non-zeros in Jacobian row
    pub fn flexedge_J_rownnz(&self) -> &[i32] {
        assert!(
            !self.raw().flexedge_J_rownnz.is_null(),
            "Pointer flexedge_J_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().flexedge_J_rownnz, self.model.nflexedge()) }
    }

    /// number of non-zeros in Jacobian row
    pub fn flexedge_J_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().flexedge_J_rownnz.is_null(),
            "Pointer flexedge_J_rownnz is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().flexedge_J_rownnz, self.model.nflexedge())
        }
    }

    /// row start address in colind array
    pub fn flexedge_J_rowadr(&self) -> &[i32] {
        assert!(
            !self.raw().flexedge_J_rowadr.is_null(),
            "Pointer flexedge_J_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().flexedge_J_rowadr, self.model.nflexedge()) }
    }

    /// row start address in colind array
    pub fn flexedge_J_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().flexedge_J_rowadr.is_null(),
            "Pointer flexedge_J_rowadr is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().flexedge_J_rowadr, self.model.nflexedge())
        }
    }

    /// column indices in sparse Jacobian
    pub fn flexedge_J_colind(&self) -> &[i32] {
        assert!(
            !self.raw().flexedge_J_colind.is_null(),
            "Pointer flexedge_J_colind is null"
        );
        unsafe {
            std::slice::from_raw_parts(
                self.raw().flexedge_J_colind,
                self.model.nflexedge() * self.model.nv(),
            )
        }
    }

    /// column indices in sparse Jacobian
    pub fn flexedge_J_colind_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().flexedge_J_colind.is_null(),
            "Pointer flexedge_J_colind is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(
                self.raw_mut().flexedge_J_colind,
                self.model.nflexedge() * self.model.nv(),
            )
        }
    }

    /// flex edge Jacobian
    pub fn flexedge_J(&self) -> &[mjtNum] {
        assert!(
            !self.raw().flexedge_J.is_null(),
            "Pointer flexedge_J is null"
        );
        unsafe {
            std::slice::from_raw_parts(
                self.raw().flexedge_J,
                self.model.nflexedge() * self.model.nv(),
            )
        }
    }

    /// flex edge Jacobian
    pub fn flexedge_J_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().flexedge_J.is_null(),
            "Pointer flexedge_J is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(
                self.raw_mut().flexedge_J,
                self.model.nflexedge() * self.model.nv(),
            )
        }
    }

    /// flex edge lengths
    pub fn flexedge_length(&self) -> &[mjtNum] {
        assert!(
            !self.raw().flexedge_length.is_null(),
            "Pointer flexedge_length is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().flexedge_length, self.model.nflexedge()) }
    }

    /// flex edge lengths
    pub fn flexedge_length_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().flexedge_length.is_null(),
            "Pointer flexedge_length is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().flexedge_length, self.model.nflexedge())
        }
    }

    /// global bounding box (center, size)
    pub fn bvh_aabb_dyn(&self) -> &[mjtNum] {
        assert!(
            !self.raw().bvh_aabb_dyn.is_null(),
            "Pointer bvh_aabb_dyn is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().bvh_aabb_dyn, self.model.nbvhdynamic() * 6) }
    }

    /// global bounding box (center, size)
    pub fn bvh_aabb_dyn_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().bvh_aabb_dyn.is_null(),
            "Pointer bvh_aabb_dyn is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(
                self.raw_mut().bvh_aabb_dyn,
                self.model.nbvhdynamic() * 6,
            )
        }
    }

    /// start address of tendon's path
    pub fn ten_wrapadr(&self) -> &[i32] {
        assert!(
            !self.raw().ten_wrapadr.is_null(),
            "Pointer ten_wrapadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().ten_wrapadr, self.model.ntendon()) }
    }

    /// start address of tendon's path
    pub fn ten_wrapadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().ten_wrapadr.is_null(),
            "Pointer ten_wrapadr is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().ten_wrapadr, self.model.ntendon()) }
    }

    /// number of wrap points in path
    pub fn ten_wrapnum(&self) -> &[i32] {
        assert!(
            !self.raw().ten_wrapnum.is_null(),
            "Pointer ten_wrapnum is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().ten_wrapnum, self.model.ntendon()) }
    }

    /// number of wrap points in path
    pub fn ten_wrapnum_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().ten_wrapnum.is_null(),
            "Pointer ten_wrapnum is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().ten_wrapnum, self.model.ntendon()) }
    }

    /// number of non-zeros in Jacobian row
    pub fn ten_J_rownnz(&self) -> &[i32] {
        assert!(
            !self.raw().ten_J_rownnz.is_null(),
            "Pointer ten_J_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().ten_J_rownnz, self.model.ntendon()) }
    }

    /// number of non-zeros in Jacobian row
    pub fn ten_J_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().ten_J_rownnz.is_null(),
            "Pointer ten_J_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().ten_J_rownnz, self.model.ntendon()) }
    }

    /// row start address in colind array
    pub fn ten_J_rowadr(&self) -> &[i32] {
        assert!(
            !self.raw().ten_J_rowadr.is_null(),
            "Pointer ten_J_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().ten_J_rowadr, self.model.ntendon()) }
    }

    /// row start address in colind array
    pub fn ten_J_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().ten_J_rowadr.is_null(),
            "Pointer ten_J_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().ten_J_rowadr, self.model.ntendon()) }
    }

    /// column indices in sparse Jacobian
    pub fn ten_J_colind(&self) -> &[i32] {
        assert!(
            !self.raw().ten_J_colind.is_null(),
            "Pointer ten_J_colind is null"
        );
        unsafe {
            std::slice::from_raw_parts(
                self.raw().ten_J_colind,
                self.model.ntendon() * self.model.nv(),
            )
        }
    }

    /// column indices in sparse Jacobian
    pub fn ten_J_colind_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().ten_J_colind.is_null(),
            "Pointer ten_J_colind is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(
                self.raw_mut().ten_J_colind,
                self.model.ntendon() * self.model.nv(),
            )
        }
    }

    /// tendon Jacobian
    pub fn ten_J(&self) -> &[mjtNum] {
        assert!(!self.raw().ten_J.is_null(), "Pointer ten_J is null");
        unsafe {
            std::slice::from_raw_parts(self.raw().ten_J, self.model.ntendon() * self.model.nv())
        }
    }

    /// tendon Jacobian
    pub fn ten_J_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().ten_J.is_null(), "Pointer ten_J is null");
        unsafe {
            std::slice::from_raw_parts_mut(
                self.raw_mut().ten_J,
                self.model.ntendon() * self.model.nv(),
            )
        }
    }

    /// tendon lengths
    pub fn ten_length(&self) -> &[mjtNum] {
        assert!(
            !self.raw().ten_length.is_null(),
            "Pointer ten_length is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().ten_length, self.model.ntendon()) }
    }

    /// tendon lengths
    pub fn ten_length_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().ten_length.is_null(),
            "Pointer ten_length is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().ten_length, self.model.ntendon()) }
    }

    /// geom id; -1: site; -2: pulley
    pub fn wrap_obj(&self) -> &[i32] {
        assert!(!self.raw().wrap_obj.is_null(), "Pointer wrap_obj is null");
        unsafe { std::slice::from_raw_parts(self.raw().wrap_obj, self.model.nwrap() * 2) }
    }

    /// geom id; -1: site; -2: pulley
    pub fn wrap_obj_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().wrap_obj.is_null(), "Pointer wrap_obj is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().wrap_obj, self.model.nwrap() * 2) }
    }

    /// Cartesian 3D points in all paths
    pub fn wrap_xpos(&self) -> &[mjtNum] {
        assert!(!self.raw().wrap_xpos.is_null(), "Pointer wrap_xpos is null");
        unsafe { std::slice::from_raw_parts(self.raw().wrap_xpos, self.model.nwrap() * 6) }
    }

    /// Cartesian 3D points in all paths
    pub fn wrap_xpos_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().wrap_xpos.is_null(), "Pointer wrap_xpos is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().wrap_xpos, self.model.nwrap() * 6) }
    }

    /// actuator lengths
    pub fn actuator_length(&self) -> &[mjtNum] {
        assert!(
            !self.raw().actuator_length.is_null(),
            "Pointer actuator_length is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().actuator_length, self.model.nu()) }
    }

    /// actuator lengths
    pub fn actuator_length_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().actuator_length.is_null(),
            "Pointer actuator_length is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().actuator_length, self.model.nu()) }
    }

    /// number of non-zeros in actuator_moment row
    pub fn moment_rownnz(&self) -> &[i32] {
        assert!(
            !self.raw().moment_rownnz.is_null(),
            "Pointer moment_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().moment_rownnz, self.model.nu()) }
    }

    /// number of non-zeros in actuator_moment row
    pub fn moment_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().moment_rownnz.is_null(),
            "Pointer moment_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().moment_rownnz, self.model.nu()) }
    }

    /// row start address in colind array
    pub fn moment_rowadr(&self) -> &[i32] {
        assert!(
            !self.raw().moment_rowadr.is_null(),
            "Pointer moment_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().moment_rowadr, self.model.nu()) }
    }

    /// row start address in colind array
    pub fn moment_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().moment_rowadr.is_null(),
            "Pointer moment_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().moment_rowadr, self.model.nu()) }
    }

    /// column indices in sparse Jacobian
    pub fn moment_colind(&self) -> &[i32] {
        assert!(
            !self.raw().moment_colind.is_null(),
            "Pointer moment_colind is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().moment_colind, self.model.nJmom()) }
    }

    /// column indices in sparse Jacobian
    pub fn moment_colind_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().moment_colind.is_null(),
            "Pointer moment_colind is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().moment_colind, self.model.nJmom()) }
    }

    /// actuator moments
    pub fn actuator_moment(&self) -> &[mjtNum] {
        assert!(
            !self.raw().actuator_moment.is_null(),
            "Pointer actuator_moment is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().actuator_moment, self.model.nJmom()) }
    }

    /// actuator moments
    pub fn actuator_moment_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().actuator_moment.is_null(),
            "Pointer actuator_moment is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().actuator_moment, self.model.nJmom())
        }
    }

    /// com-based composite inertia and mass
    pub fn crb(&self) -> &[mjtNum] {
        assert!(!self.raw().crb.is_null(), "Pointer crb is null");
        unsafe { std::slice::from_raw_parts(self.raw().crb, self.model.nbody() * 10) }
    }

    /// com-based composite inertia and mass
    pub fn crb_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().crb.is_null(), "Pointer crb is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().crb, self.model.nbody() * 10) }
    }

    /// inertia (sparse)
    pub fn qM(&self) -> &[mjtNum] {
        assert!(!self.raw().qM.is_null(), "Pointer qM is null");
        unsafe { std::slice::from_raw_parts(self.raw().qM, self.model.nM()) }
    }

    /// inertia (sparse)
    pub fn qM_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().qM.is_null(), "Pointer qM is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qM, self.model.nM()) }
    }

    /// reduced inertia (compressed sparse row)
    pub fn M(&self) -> &[mjtNum] {
        assert!(!self.raw().M.is_null(), "Pointer M is null");
        unsafe { std::slice::from_raw_parts(self.raw().M, self.model.nC()) }
    }

    /// reduced inertia (compressed sparse row)
    pub fn M_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().M.is_null(), "Pointer M is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().M, self.model.nC()) }
    }

    /// L'*D*L factorization of M (sparse)
    pub fn qLD(&self) -> &[mjtNum] {
        assert!(!self.raw().qLD.is_null(), "Pointer qLD is null");
        unsafe { std::slice::from_raw_parts(self.raw().qLD, self.model.nC()) }
    }

    /// L'*D*L factorization of M (sparse)
    pub fn qLD_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().qLD.is_null(), "Pointer qLD is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qLD, self.model.nC()) }
    }

    /// 1/diag(D)
    pub fn qLDiagInv(&self) -> &[mjtNum] {
        assert!(!self.raw().qLDiagInv.is_null(), "Pointer qLDiagInv is null");
        unsafe { std::slice::from_raw_parts(self.raw().qLDiagInv, self.model.nv()) }
    }

    /// 1/diag(D)
    pub fn qLDiagInv_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().qLDiagInv.is_null(), "Pointer qLDiagInv is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qLDiagInv, self.model.nv()) }
    }

    /// was bounding volume checked for collision
    pub fn bvh_active(&self) -> &[u8] {
        assert!(
            !self.raw().bvh_active.is_null(),
            "Pointer bvh_active is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().bvh_active, self.model.nbvh()) }
    }

    /// was bounding volume checked for collision
    pub fn bvh_active_mut(&mut self) -> &mut [u8] {
        assert!(
            !self.raw().bvh_active.is_null(),
            "Pointer bvh_active is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().bvh_active, self.model.nbvh()) }
    }

    /// flex edge velocities
    pub fn flexedge_velocity(&self) -> &[mjtNum] {
        assert!(
            !self.raw().flexedge_velocity.is_null(),
            "Pointer flexedge_velocity is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().flexedge_velocity, self.model.nflexedge()) }
    }

    /// flex edge velocities
    pub fn flexedge_velocity_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().flexedge_velocity.is_null(),
            "Pointer flexedge_velocity is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().flexedge_velocity, self.model.nflexedge())
        }
    }

    /// tendon velocities
    pub fn ten_velocity(&self) -> &[mjtNum] {
        assert!(
            !self.raw().ten_velocity.is_null(),
            "Pointer ten_velocity is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().ten_velocity, self.model.ntendon()) }
    }

    /// tendon velocities
    pub fn ten_velocity_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().ten_velocity.is_null(),
            "Pointer ten_velocity is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().ten_velocity, self.model.ntendon()) }
    }

    /// actuator velocities
    pub fn actuator_velocity(&self) -> &[mjtNum] {
        assert!(
            !self.raw().actuator_velocity.is_null(),
            "Pointer actuator_velocity is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().actuator_velocity, self.model.nu()) }
    }

    /// actuator velocities
    pub fn actuator_velocity_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().actuator_velocity.is_null(),
            "Pointer actuator_velocity is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().actuator_velocity, self.model.nu()) }
    }

    /// com-based velocity (rot:lin)
    pub fn cvel(&self) -> &[mjtNum] {
        assert!(!self.raw().cvel.is_null(), "Pointer cvel is null");
        unsafe { std::slice::from_raw_parts(self.raw().cvel, self.model.nbody() * 6) }
    }

    /// com-based velocity (rot:lin)
    pub fn cvel_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().cvel.is_null(), "Pointer cvel is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().cvel, self.model.nbody() * 6) }
    }

    /// time-derivative of cdof (rot:lin)
    pub fn cdof_dot(&self) -> &[mjtNum] {
        assert!(!self.raw().cdof_dot.is_null(), "Pointer cdof_dot is null");
        unsafe { std::slice::from_raw_parts(self.raw().cdof_dot, self.model.nv() * 6) }
    }

    /// time-derivative of cdof (rot:lin)
    pub fn cdof_dot_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().cdof_dot.is_null(), "Pointer cdof_dot is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().cdof_dot, self.model.nv() * 6) }
    }

    /// C(qpos,qvel)
    pub fn qfrc_bias(&self) -> &[mjtNum] {
        assert!(!self.raw().qfrc_bias.is_null(), "Pointer qfrc_bias is null");
        unsafe { std::slice::from_raw_parts(self.raw().qfrc_bias, self.model.nv()) }
    }

    /// C(qpos,qvel)
    pub fn qfrc_bias_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().qfrc_bias.is_null(), "Pointer qfrc_bias is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qfrc_bias, self.model.nv()) }
    }

    /// passive spring force
    pub fn qfrc_spring(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qfrc_spring.is_null(),
            "Pointer qfrc_spring is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qfrc_spring, self.model.nv()) }
    }

    /// passive spring force
    pub fn qfrc_spring_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qfrc_spring.is_null(),
            "Pointer qfrc_spring is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qfrc_spring, self.model.nv()) }
    }

    /// passive damper force
    pub fn qfrc_damper(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qfrc_damper.is_null(),
            "Pointer qfrc_damper is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qfrc_damper, self.model.nv()) }
    }

    /// passive damper force
    pub fn qfrc_damper_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qfrc_damper.is_null(),
            "Pointer qfrc_damper is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qfrc_damper, self.model.nv()) }
    }

    /// passive gravity compensation force
    pub fn qfrc_gravcomp(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qfrc_gravcomp.is_null(),
            "Pointer qfrc_gravcomp is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qfrc_gravcomp, self.model.nv()) }
    }

    /// passive gravity compensation force
    pub fn qfrc_gravcomp_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qfrc_gravcomp.is_null(),
            "Pointer qfrc_gravcomp is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qfrc_gravcomp, self.model.nv()) }
    }

    /// passive fluid force
    pub fn qfrc_fluid(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qfrc_fluid.is_null(),
            "Pointer qfrc_fluid is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qfrc_fluid, self.model.nv()) }
    }

    /// passive fluid force
    pub fn qfrc_fluid_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qfrc_fluid.is_null(),
            "Pointer qfrc_fluid is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qfrc_fluid, self.model.nv()) }
    }

    /// total passive force
    pub fn qfrc_passive(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qfrc_passive.is_null(),
            "Pointer qfrc_passive is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qfrc_passive, self.model.nv()) }
    }

    /// total passive force
    pub fn qfrc_passive_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qfrc_passive.is_null(),
            "Pointer qfrc_passive is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qfrc_passive, self.model.nv()) }
    }

    /// linear velocity of subtree com
    pub fn subtree_linvel(&self) -> &[mjtNum] {
        assert!(
            !self.raw().subtree_linvel.is_null(),
            "Pointer subtree_linvel is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().subtree_linvel, self.model.nbody() * 3) }
    }

    /// linear velocity of subtree com
    pub fn subtree_linvel_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().subtree_linvel.is_null(),
            "Pointer subtree_linvel is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().subtree_linvel, self.model.nbody() * 3)
        }
    }

    /// angular momentum about subtree com
    pub fn subtree_angmom(&self) -> &[mjtNum] {
        assert!(
            !self.raw().subtree_angmom.is_null(),
            "Pointer subtree_angmom is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().subtree_angmom, self.model.nbody() * 3) }
    }

    /// angular momentum about subtree com
    pub fn subtree_angmom_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().subtree_angmom.is_null(),
            "Pointer subtree_angmom is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().subtree_angmom, self.model.nbody() * 3)
        }
    }

    /// L'*D*L factorization of modified M
    pub fn qH(&self) -> &[mjtNum] {
        assert!(!self.raw().qH.is_null(), "Pointer qH is null");
        unsafe { std::slice::from_raw_parts(self.raw().qH, self.model.nC()) }
    }

    /// L'*D*L factorization of modified M
    pub fn qH_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().qH.is_null(), "Pointer qH is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qH, self.model.nC()) }
    }

    /// 1/diag(D) of modified M
    pub fn qHDiagInv(&self) -> &[mjtNum] {
        assert!(!self.raw().qHDiagInv.is_null(), "Pointer qHDiagInv is null");
        unsafe { std::slice::from_raw_parts(self.raw().qHDiagInv, self.model.nv()) }
    }

    /// 1/diag(D) of modified M
    pub fn qHDiagInv_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().qHDiagInv.is_null(), "Pointer qHDiagInv is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qHDiagInv, self.model.nv()) }
    }

    /// body-dof: non-zeros in each row
    pub fn B_rownnz(&self) -> &[i32] {
        assert!(!self.raw().B_rownnz.is_null(), "Pointer B_rownnz is null");
        unsafe { std::slice::from_raw_parts(self.raw().B_rownnz, self.model.nbody()) }
    }

    /// body-dof: non-zeros in each row
    pub fn B_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().B_rownnz.is_null(), "Pointer B_rownnz is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().B_rownnz, self.model.nbody()) }
    }

    /// body-dof: address of each row in B_colind
    pub fn B_rowadr(&self) -> &[i32] {
        assert!(!self.raw().B_rowadr.is_null(), "Pointer B_rowadr is null");
        unsafe { std::slice::from_raw_parts(self.raw().B_rowadr, self.model.nbody()) }
    }

    /// body-dof: address of each row in B_colind
    pub fn B_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().B_rowadr.is_null(), "Pointer B_rowadr is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().B_rowadr, self.model.nbody()) }
    }

    /// body-dof: column indices of non-zeros
    pub fn B_colind(&self) -> &[i32] {
        assert!(!self.raw().B_colind.is_null(), "Pointer B_colind is null");
        unsafe { std::slice::from_raw_parts(self.raw().B_colind, self.model.nB()) }
    }

    /// body-dof: column indices of non-zeros
    pub fn B_colind_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().B_colind.is_null(), "Pointer B_colind is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().B_colind, self.model.nB()) }
    }

    /// reduced inertia: non-zeros in each row
    pub fn M_rownnz(&self) -> &[i32] {
        assert!(!self.raw().M_rownnz.is_null(), "Pointer M_rownnz is null");
        unsafe { std::slice::from_raw_parts(self.raw().M_rownnz, self.model.nv()) }
    }

    /// reduced inertia: non-zeros in each row
    pub fn M_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().M_rownnz.is_null(), "Pointer M_rownnz is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().M_rownnz, self.model.nv()) }
    }

    /// reduced inertia: address of each row in M_colind
    pub fn M_rowadr(&self) -> &[i32] {
        assert!(!self.raw().M_rowadr.is_null(), "Pointer M_rowadr is null");
        unsafe { std::slice::from_raw_parts(self.raw().M_rowadr, self.model.nv()) }
    }

    /// reduced inertia: address of each row in M_colind
    pub fn M_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().M_rowadr.is_null(), "Pointer M_rowadr is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().M_rowadr, self.model.nv()) }
    }

    /// reduced inertia: column indices of non-zeros
    pub fn M_colind(&self) -> &[i32] {
        assert!(!self.raw().M_colind.is_null(), "Pointer M_colind is null");
        unsafe { std::slice::from_raw_parts(self.raw().M_colind, self.model.nC()) }
    }

    /// reduced inertia: column indices of non-zeros
    pub fn M_colind_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().M_colind.is_null(), "Pointer M_colind is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().M_colind, self.model.nC()) }
    }

    /// index mapping from qM to M
    pub fn mapM2M(&self) -> &[i32] {
        assert!(!self.raw().mapM2M.is_null(), "Pointer mapM2M is null");
        unsafe { std::slice::from_raw_parts(self.raw().mapM2M, self.model.nC()) }
    }

    /// index mapping from qM to M
    pub fn mapM2M_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().mapM2M.is_null(), "Pointer mapM2M is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().mapM2M, self.model.nC()) }
    }

    /// full inertia: non-zeros in each row
    pub fn D_rownnz(&self) -> &[i32] {
        assert!(!self.raw().D_rownnz.is_null(), "Pointer D_rownnz is null");
        unsafe { std::slice::from_raw_parts(self.raw().D_rownnz, self.model.nv()) }
    }

    /// full inertia: non-zeros in each row
    pub fn D_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().D_rownnz.is_null(), "Pointer D_rownnz is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().D_rownnz, self.model.nv()) }
    }

    /// full inertia: address of each row in D_colind
    pub fn D_rowadr(&self) -> &[i32] {
        assert!(!self.raw().D_rowadr.is_null(), "Pointer D_rowadr is null");
        unsafe { std::slice::from_raw_parts(self.raw().D_rowadr, self.model.nv()) }
    }

    /// full inertia: address of each row in D_colind
    pub fn D_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().D_rowadr.is_null(), "Pointer D_rowadr is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().D_rowadr, self.model.nv()) }
    }

    /// full inertia: index of diagonal element
    pub fn D_diag(&self) -> &[i32] {
        assert!(!self.raw().D_diag.is_null(), "Pointer D_diag is null");
        unsafe { std::slice::from_raw_parts(self.raw().D_diag, self.model.nv()) }
    }

    /// full inertia: index of diagonal element
    pub fn D_diag_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().D_diag.is_null(), "Pointer D_diag is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().D_diag, self.model.nv()) }
    }

    /// full inertia: column indices of non-zeros
    pub fn D_colind(&self) -> &[i32] {
        assert!(!self.raw().D_colind.is_null(), "Pointer D_colind is null");
        unsafe { std::slice::from_raw_parts(self.raw().D_colind, self.model.nD()) }
    }

    /// full inertia: column indices of non-zeros
    pub fn D_colind_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().D_colind.is_null(), "Pointer D_colind is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().D_colind, self.model.nD()) }
    }

    /// index mapping from qM to D
    pub fn mapM2D(&self) -> &[i32] {
        assert!(!self.raw().mapM2D.is_null(), "Pointer mapM2D is null");
        unsafe { std::slice::from_raw_parts(self.raw().mapM2D, self.model.nD()) }
    }

    /// index mapping from qM to D
    pub fn mapM2D_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().mapM2D.is_null(), "Pointer mapM2D is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().mapM2D, self.model.nD()) }
    }

    /// index mapping from D to qM
    pub fn mapD2M(&self) -> &[i32] {
        assert!(!self.raw().mapD2M.is_null(), "Pointer mapD2M is null");
        unsafe { std::slice::from_raw_parts(self.raw().mapD2M, self.model.nM()) }
    }

    /// index mapping from D to qM
    pub fn mapD2M_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().mapD2M.is_null(), "Pointer mapD2M is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().mapD2M, self.model.nM()) }
    }

    /// d (passive + actuator - bias) / d qvel
    pub fn qDeriv(&self) -> &[mjtNum] {
        assert!(!self.raw().qDeriv.is_null(), "Pointer qDeriv is null");
        unsafe { std::slice::from_raw_parts(self.raw().qDeriv, self.model.nD()) }
    }

    /// d (passive + actuator - bias) / d qvel
    pub fn qDeriv_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().qDeriv.is_null(), "Pointer qDeriv is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qDeriv, self.model.nD()) }
    }

    /// sparse LU of (qM - dt*qDeriv)
    pub fn qLU(&self) -> &[mjtNum] {
        assert!(!self.raw().qLU.is_null(), "Pointer qLU is null");
        unsafe { std::slice::from_raw_parts(self.raw().qLU, self.model.nD()) }
    }

    /// sparse LU of (qM - dt*qDeriv)
    pub fn qLU_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().qLU.is_null(), "Pointer qLU is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qLU, self.model.nD()) }
    }

    /// actuator force in actuation space
    pub fn actuator_force(&self) -> &[mjtNum] {
        assert!(
            !self.raw().actuator_force.is_null(),
            "Pointer actuator_force is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().actuator_force, self.model.nu()) }
    }

    /// actuator force in actuation space
    pub fn actuator_force_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().actuator_force.is_null(),
            "Pointer actuator_force is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().actuator_force, self.model.nu()) }
    }

    /// actuator force
    pub fn qfrc_actuator(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qfrc_actuator.is_null(),
            "Pointer qfrc_actuator is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qfrc_actuator, self.model.nv()) }
    }

    /// actuator force
    pub fn qfrc_actuator_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qfrc_actuator.is_null(),
            "Pointer qfrc_actuator is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qfrc_actuator, self.model.nv()) }
    }

    /// net unconstrained force
    pub fn qfrc_smooth(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qfrc_smooth.is_null(),
            "Pointer qfrc_smooth is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qfrc_smooth, self.model.nv()) }
    }

    /// net unconstrained force
    pub fn qfrc_smooth_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qfrc_smooth.is_null(),
            "Pointer qfrc_smooth is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qfrc_smooth, self.model.nv()) }
    }

    /// unconstrained acceleration
    pub fn qacc_smooth(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qacc_smooth.is_null(),
            "Pointer qacc_smooth is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qacc_smooth, self.model.nv()) }
    }

    /// unconstrained acceleration
    pub fn qacc_smooth_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qacc_smooth.is_null(),
            "Pointer qacc_smooth is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qacc_smooth, self.model.nv()) }
    }

    /// constraint force
    pub fn qfrc_constraint(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qfrc_constraint.is_null(),
            "Pointer qfrc_constraint is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qfrc_constraint, self.model.nv()) }
    }

    /// constraint force
    pub fn qfrc_constraint_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qfrc_constraint.is_null(),
            "Pointer qfrc_constraint is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qfrc_constraint, self.model.nv()) }
    }

    /// net external force; should equal: qfrc_applied + J'*xfrc_applied + qfrc_actuator
    pub fn qfrc_inverse(&self) -> &[mjtNum] {
        assert!(
            !self.raw().qfrc_inverse.is_null(),
            "Pointer qfrc_inverse is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().qfrc_inverse, self.model.nv()) }
    }

    /// net external force; should equal: qfrc_applied + J'*xfrc_applied + qfrc_actuator
    pub fn qfrc_inverse_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().qfrc_inverse.is_null(),
            "Pointer qfrc_inverse is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().qfrc_inverse, self.model.nv()) }
    }

    /// com-based acceleration
    pub fn cacc(&self) -> &[mjtNum] {
        assert!(!self.raw().cacc.is_null(), "Pointer cacc is null");
        unsafe { std::slice::from_raw_parts(self.raw().cacc, self.model.nbody() * 6) }
    }

    /// com-based acceleration
    pub fn cacc_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().cacc.is_null(), "Pointer cacc is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().cacc, self.model.nbody() * 6) }
    }

    /// com-based interaction force with parent
    pub fn cfrc_int(&self) -> &[mjtNum] {
        assert!(!self.raw().cfrc_int.is_null(), "Pointer cfrc_int is null");
        unsafe { std::slice::from_raw_parts(self.raw().cfrc_int, self.model.nbody() * 6) }
    }

    /// com-based interaction force with parent
    pub fn cfrc_int_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().cfrc_int.is_null(), "Pointer cfrc_int is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().cfrc_int, self.model.nbody() * 6) }
    }

    /// com-based external force on body
    pub fn cfrc_ext(&self) -> &[mjtNum] {
        assert!(!self.raw().cfrc_ext.is_null(), "Pointer cfrc_ext is null");
        unsafe { std::slice::from_raw_parts(self.raw().cfrc_ext, self.model.nbody() * 6) }
    }

    /// com-based external force on body
    pub fn cfrc_ext_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().cfrc_ext.is_null(), "Pointer cfrc_ext is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().cfrc_ext, self.model.nbody() * 6) }
    }

    /// array of all detected contacts
    pub fn contact(&self) -> &[mjContact] {
        assert!(!self.raw().contact.is_null(), "Pointer contact is null");
        unsafe { std::slice::from_raw_parts(self.raw().contact, self.ncon()) }
    }

    /// array of all detected contacts
    pub fn contact_mut(&mut self) -> &mut [mjContact] {
        assert!(!self.raw().contact.is_null(), "Pointer contact is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().contact, self.ncon()) }
    }

    /// constraint type (mjtConstraint)
    pub fn efc_type(&self) -> &[i32] {
        assert!(!self.raw().efc_type.is_null(), "Pointer efc_type is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_type, self.nefc()) }
    }

    /// constraint type (mjtConstraint)
    pub fn efc_type_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().efc_type.is_null(), "Pointer efc_type is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_type, self.nefc()) }
    }

    /// id of object of specified type
    pub fn efc_id(&self) -> &[i32] {
        assert!(!self.raw().efc_id.is_null(), "Pointer efc_id is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_id, self.nefc()) }
    }

    /// id of object of specified type
    pub fn efc_id_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().efc_id.is_null(), "Pointer efc_id is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_id, self.nefc()) }
    }

    /// number of non-zeros in constraint Jacobian row
    pub fn efc_J_rownnz(&self) -> &[i32] {
        assert!(
            !self.raw().efc_J_rownnz.is_null(),
            "Pointer efc_J_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_J_rownnz, self.nefc()) }
    }

    /// number of non-zeros in constraint Jacobian row
    pub fn efc_J_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_J_rownnz.is_null(),
            "Pointer efc_J_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_J_rownnz, self.nefc()) }
    }

    /// row start address in colind array
    pub fn efc_J_rowadr(&self) -> &[i32] {
        assert!(
            !self.raw().efc_J_rowadr.is_null(),
            "Pointer efc_J_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_J_rowadr, self.nefc()) }
    }

    /// row start address in colind array
    pub fn efc_J_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_J_rowadr.is_null(),
            "Pointer efc_J_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_J_rowadr, self.nefc()) }
    }

    /// number of subsequent rows in supernode
    pub fn efc_J_rowsuper(&self) -> &[i32] {
        assert!(
            !self.raw().efc_J_rowsuper.is_null(),
            "Pointer efc_J_rowsuper is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_J_rowsuper, self.nefc()) }
    }

    /// number of subsequent rows in supernode
    pub fn efc_J_rowsuper_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_J_rowsuper.is_null(),
            "Pointer efc_J_rowsuper is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_J_rowsuper, self.nefc()) }
    }

    /// column indices in constraint Jacobian
    pub fn efc_J_colind(&self) -> &[i32] {
        assert!(
            !self.raw().efc_J_colind.is_null(),
            "Pointer efc_J_colind is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_J_colind, self.nJ()) }
    }

    /// column indices in constraint Jacobian
    pub fn efc_J_colind_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_J_colind.is_null(),
            "Pointer efc_J_colind is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_J_colind, self.nJ()) }
    }

    /// number of non-zeros in constraint Jacobian row T
    pub fn efc_JT_rownnz(&self) -> &[i32] {
        assert!(
            !self.raw().efc_JT_rownnz.is_null(),
            "Pointer efc_JT_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_JT_rownnz, self.model.nv()) }
    }

    /// number of non-zeros in constraint Jacobian row T
    pub fn efc_JT_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_JT_rownnz.is_null(),
            "Pointer efc_JT_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_JT_rownnz, self.model.nv()) }
    }

    /// row start address in colind array              T
    pub fn efc_JT_rowadr(&self) -> &[i32] {
        assert!(
            !self.raw().efc_JT_rowadr.is_null(),
            "Pointer efc_JT_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_JT_rowadr, self.model.nv()) }
    }

    /// row start address in colind array              T
    pub fn efc_JT_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_JT_rowadr.is_null(),
            "Pointer efc_JT_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_JT_rowadr, self.model.nv()) }
    }

    /// number of subsequent rows in supernode         T
    pub fn efc_JT_rowsuper(&self) -> &[i32] {
        assert!(
            !self.raw().efc_JT_rowsuper.is_null(),
            "Pointer efc_JT_rowsuper is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_JT_rowsuper, self.model.nv()) }
    }

    /// number of subsequent rows in supernode         T
    pub fn efc_JT_rowsuper_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_JT_rowsuper.is_null(),
            "Pointer efc_JT_rowsuper is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_JT_rowsuper, self.model.nv()) }
    }

    /// column indices in constraint Jacobian          T
    pub fn efc_JT_colind(&self) -> &[i32] {
        assert!(
            !self.raw().efc_JT_colind.is_null(),
            "Pointer efc_JT_colind is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_JT_colind, self.nJ()) }
    }

    /// column indices in constraint Jacobian          T
    pub fn efc_JT_colind_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_JT_colind.is_null(),
            "Pointer efc_JT_colind is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_JT_colind, self.nJ()) }
    }

    /// constraint Jacobian
    pub fn efc_J(&self) -> &[mjtNum] {
        assert!(!self.raw().efc_J.is_null(), "Pointer efc_J is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_J, self.nJ()) }
    }

    /// constraint Jacobian
    pub fn efc_J_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().efc_J.is_null(), "Pointer efc_J is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_J, self.nJ()) }
    }

    /// constraint Jacobian transposed
    pub fn efc_JT(&self) -> &[mjtNum] {
        assert!(!self.raw().efc_JT.is_null(), "Pointer efc_JT is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_JT, self.nJ()) }
    }

    /// constraint Jacobian transposed
    pub fn efc_JT_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().efc_JT.is_null(), "Pointer efc_JT is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_JT, self.nJ()) }
    }

    /// constraint position (equality, contact)
    pub fn efc_pos(&self) -> &[mjtNum] {
        assert!(!self.raw().efc_pos.is_null(), "Pointer efc_pos is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_pos, self.nefc()) }
    }

    /// constraint position (equality, contact)
    pub fn efc_pos_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().efc_pos.is_null(), "Pointer efc_pos is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_pos, self.nefc()) }
    }

    /// inclusion margin (contact)
    pub fn efc_margin(&self) -> &[mjtNum] {
        assert!(
            !self.raw().efc_margin.is_null(),
            "Pointer efc_margin is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_margin, self.nefc()) }
    }

    /// inclusion margin (contact)
    pub fn efc_margin_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().efc_margin.is_null(),
            "Pointer efc_margin is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_margin, self.nefc()) }
    }

    /// frictionloss (friction)
    pub fn efc_frictionloss(&self) -> &[mjtNum] {
        assert!(
            !self.raw().efc_frictionloss.is_null(),
            "Pointer efc_frictionloss is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_frictionloss, self.nefc()) }
    }

    /// frictionloss (friction)
    pub fn efc_frictionloss_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().efc_frictionloss.is_null(),
            "Pointer efc_frictionloss is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_frictionloss, self.nefc()) }
    }

    /// approximation to diagonal of A
    pub fn efc_diagApprox(&self) -> &[mjtNum] {
        assert!(
            !self.raw().efc_diagApprox.is_null(),
            "Pointer efc_diagApprox is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_diagApprox, self.nefc()) }
    }

    /// approximation to diagonal of A
    pub fn efc_diagApprox_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().efc_diagApprox.is_null(),
            "Pointer efc_diagApprox is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_diagApprox, self.nefc()) }
    }

    /// stiffness, damping, impedance, imp'
    pub fn efc_KBIP(&self) -> &[mjtNum] {
        assert!(!self.raw().efc_KBIP.is_null(), "Pointer efc_KBIP is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_KBIP, self.nefc() * 4) }
    }

    /// stiffness, damping, impedance, imp'
    pub fn efc_KBIP_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().efc_KBIP.is_null(), "Pointer efc_KBIP is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_KBIP, self.nefc() * 4) }
    }

    /// constraint mass
    pub fn efc_D(&self) -> &[mjtNum] {
        assert!(!self.raw().efc_D.is_null(), "Pointer efc_D is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_D, self.nefc()) }
    }

    /// constraint mass
    pub fn efc_D_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().efc_D.is_null(), "Pointer efc_D is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_D, self.nefc()) }
    }

    /// inverse constraint mass
    pub fn efc_R(&self) -> &[mjtNum] {
        assert!(!self.raw().efc_R.is_null(), "Pointer efc_R is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_R, self.nefc()) }
    }

    /// inverse constraint mass
    pub fn efc_R_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().efc_R.is_null(), "Pointer efc_R is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_R, self.nefc()) }
    }

    /// first efc address involving tendon; -1: none
    pub fn tendon_efcadr(&self) -> &[i32] {
        assert!(
            !self.raw().tendon_efcadr.is_null(),
            "Pointer tendon_efcadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().tendon_efcadr, self.model.ntendon()) }
    }

    /// first efc address involving tendon; -1: none
    pub fn tendon_efcadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().tendon_efcadr.is_null(),
            "Pointer tendon_efcadr is null"
        );
        unsafe {
            std::slice::from_raw_parts_mut(self.raw_mut().tendon_efcadr, self.model.ntendon())
        }
    }

    /// island id of this dof; -1: none
    pub fn dof_island(&self) -> &[i32] {
        assert!(
            !self.raw().dof_island.is_null(),
            "Pointer dof_island is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().dof_island, self.model.nv()) }
    }

    /// island id of this dof; -1: none
    pub fn dof_island_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().dof_island.is_null(),
            "Pointer dof_island is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().dof_island, self.model.nv()) }
    }

    /// number of dofs in this island
    pub fn island_nv(&self) -> &[i32] {
        assert!(!self.raw().island_nv.is_null(), "Pointer island_nv is null");
        unsafe { std::slice::from_raw_parts(self.raw().island_nv, self.nisland()) }
    }

    /// number of dofs in this island
    pub fn island_nv_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().island_nv.is_null(), "Pointer island_nv is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().island_nv, self.nisland()) }
    }

    /// island start address in idof vector
    pub fn island_idofadr(&self) -> &[i32] {
        assert!(
            !self.raw().island_idofadr.is_null(),
            "Pointer island_idofadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().island_idofadr, self.nisland()) }
    }

    /// island start address in idof vector
    pub fn island_idofadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().island_idofadr.is_null(),
            "Pointer island_idofadr is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().island_idofadr, self.nisland()) }
    }

    /// island start address in dof vector
    pub fn island_dofadr(&self) -> &[i32] {
        assert!(
            !self.raw().island_dofadr.is_null(),
            "Pointer island_dofadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().island_dofadr, self.nisland()) }
    }

    /// island start address in dof vector
    pub fn island_dofadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().island_dofadr.is_null(),
            "Pointer island_dofadr is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().island_dofadr, self.nisland()) }
    }

    /// map from dof to idof
    pub fn map_dof2idof(&self) -> &[i32] {
        assert!(
            !self.raw().map_dof2idof.is_null(),
            "Pointer map_dof2idof is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().map_dof2idof, self.model.nv()) }
    }

    /// map from dof to idof
    pub fn map_dof2idof_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().map_dof2idof.is_null(),
            "Pointer map_dof2idof is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().map_dof2idof, self.model.nv()) }
    }

    /// map from idof to dof;  >= nidof: unconstrained
    pub fn map_idof2dof(&self) -> &[i32] {
        assert!(
            !self.raw().map_idof2dof.is_null(),
            "Pointer map_idof2dof is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().map_idof2dof, self.model.nv()) }
    }

    /// map from idof to dof;  >= nidof: unconstrained
    pub fn map_idof2dof_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().map_idof2dof.is_null(),
            "Pointer map_idof2dof is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().map_idof2dof, self.model.nv()) }
    }

    /// net unconstrained force
    pub fn ifrc_smooth(&self) -> &[mjtNum] {
        assert!(
            !self.raw().ifrc_smooth.is_null(),
            "Pointer ifrc_smooth is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().ifrc_smooth, self.nidof()) }
    }

    /// net unconstrained force
    pub fn ifrc_smooth_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().ifrc_smooth.is_null(),
            "Pointer ifrc_smooth is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().ifrc_smooth, self.nidof()) }
    }

    /// unconstrained acceleration
    pub fn iacc_smooth(&self) -> &[mjtNum] {
        assert!(
            !self.raw().iacc_smooth.is_null(),
            "Pointer iacc_smooth is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iacc_smooth, self.nidof()) }
    }

    /// unconstrained acceleration
    pub fn iacc_smooth_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().iacc_smooth.is_null(),
            "Pointer iacc_smooth is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iacc_smooth, self.nidof()) }
    }

    /// inertia: non-zeros in each row
    pub fn iM_rownnz(&self) -> &[i32] {
        assert!(!self.raw().iM_rownnz.is_null(), "Pointer iM_rownnz is null");
        unsafe { std::slice::from_raw_parts(self.raw().iM_rownnz, self.nidof()) }
    }

    /// inertia: non-zeros in each row
    pub fn iM_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().iM_rownnz.is_null(), "Pointer iM_rownnz is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iM_rownnz, self.nidof()) }
    }

    /// inertia: address of each row in iM_colind
    pub fn iM_rowadr(&self) -> &[i32] {
        assert!(!self.raw().iM_rowadr.is_null(), "Pointer iM_rowadr is null");
        unsafe { std::slice::from_raw_parts(self.raw().iM_rowadr, self.nidof()) }
    }

    /// inertia: address of each row in iM_colind
    pub fn iM_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().iM_rowadr.is_null(), "Pointer iM_rowadr is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iM_rowadr, self.nidof()) }
    }

    /// inertia: column indices of non-zeros
    pub fn iM_colind(&self) -> &[i32] {
        assert!(!self.raw().iM_colind.is_null(), "Pointer iM_colind is null");
        unsafe { std::slice::from_raw_parts(self.raw().iM_colind, self.model.nC()) }
    }

    /// inertia: column indices of non-zeros
    pub fn iM_colind_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().iM_colind.is_null(), "Pointer iM_colind is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iM_colind, self.model.nC()) }
    }

    /// total inertia (sparse)
    pub fn iM(&self) -> &[mjtNum] {
        assert!(!self.raw().iM.is_null(), "Pointer iM is null");
        unsafe { std::slice::from_raw_parts(self.raw().iM, self.model.nC()) }
    }

    /// total inertia (sparse)
    pub fn iM_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().iM.is_null(), "Pointer iM is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iM, self.model.nC()) }
    }

    /// L'*D*L factorization of M (sparse)
    pub fn iLD(&self) -> &[mjtNum] {
        assert!(!self.raw().iLD.is_null(), "Pointer iLD is null");
        unsafe { std::slice::from_raw_parts(self.raw().iLD, self.model.nC()) }
    }

    /// L'*D*L factorization of M (sparse)
    pub fn iLD_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().iLD.is_null(), "Pointer iLD is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iLD, self.model.nC()) }
    }

    /// 1/diag(D)
    pub fn iLDiagInv(&self) -> &[mjtNum] {
        assert!(!self.raw().iLDiagInv.is_null(), "Pointer iLDiagInv is null");
        unsafe { std::slice::from_raw_parts(self.raw().iLDiagInv, self.nidof()) }
    }

    /// 1/diag(D)
    pub fn iLDiagInv_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().iLDiagInv.is_null(), "Pointer iLDiagInv is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iLDiagInv, self.nidof()) }
    }

    /// acceleration
    pub fn iacc(&self) -> &[mjtNum] {
        assert!(!self.raw().iacc.is_null(), "Pointer iacc is null");
        unsafe { std::slice::from_raw_parts(self.raw().iacc, self.nidof()) }
    }

    /// acceleration
    pub fn iacc_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().iacc.is_null(), "Pointer iacc is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iacc, self.nidof()) }
    }

    /// island id of this constraint
    pub fn efc_island(&self) -> &[i32] {
        assert!(
            !self.raw().efc_island.is_null(),
            "Pointer efc_island is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_island, self.nefc()) }
    }

    /// island id of this constraint
    pub fn efc_island_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_island.is_null(),
            "Pointer efc_island is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_island, self.nefc()) }
    }

    /// number of equality constraints in island
    pub fn island_ne(&self) -> &[i32] {
        assert!(!self.raw().island_ne.is_null(), "Pointer island_ne is null");
        unsafe { std::slice::from_raw_parts(self.raw().island_ne, self.nisland()) }
    }

    /// number of equality constraints in island
    pub fn island_ne_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().island_ne.is_null(), "Pointer island_ne is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().island_ne, self.nisland()) }
    }

    /// number of friction constraints in island
    pub fn island_nf(&self) -> &[i32] {
        assert!(!self.raw().island_nf.is_null(), "Pointer island_nf is null");
        unsafe { std::slice::from_raw_parts(self.raw().island_nf, self.nisland()) }
    }

    /// number of friction constraints in island
    pub fn island_nf_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().island_nf.is_null(), "Pointer island_nf is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().island_nf, self.nisland()) }
    }

    /// number of constraints in island
    pub fn island_nefc(&self) -> &[i32] {
        assert!(
            !self.raw().island_nefc.is_null(),
            "Pointer island_nefc is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().island_nefc, self.nisland()) }
    }

    /// number of constraints in island
    pub fn island_nefc_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().island_nefc.is_null(),
            "Pointer island_nefc is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().island_nefc, self.nisland()) }
    }

    /// start address in iefc vector
    pub fn island_iefcadr(&self) -> &[i32] {
        assert!(
            !self.raw().island_iefcadr.is_null(),
            "Pointer island_iefcadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().island_iefcadr, self.nisland()) }
    }

    /// start address in iefc vector
    pub fn island_iefcadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().island_iefcadr.is_null(),
            "Pointer island_iefcadr is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().island_iefcadr, self.nisland()) }
    }

    /// map from efc to iefc
    pub fn map_efc2iefc(&self) -> &[i32] {
        assert!(
            !self.raw().map_efc2iefc.is_null(),
            "Pointer map_efc2iefc is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().map_efc2iefc, self.nefc()) }
    }

    /// map from efc to iefc
    pub fn map_efc2iefc_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().map_efc2iefc.is_null(),
            "Pointer map_efc2iefc is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().map_efc2iefc, self.nefc()) }
    }

    /// map from iefc to efc
    pub fn map_iefc2efc(&self) -> &[i32] {
        assert!(
            !self.raw().map_iefc2efc.is_null(),
            "Pointer map_iefc2efc is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().map_iefc2efc, self.nefc()) }
    }

    /// map from iefc to efc
    pub fn map_iefc2efc_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().map_iefc2efc.is_null(),
            "Pointer map_iefc2efc is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().map_iefc2efc, self.nefc()) }
    }

    /// constraint type (mjtConstraint)
    pub fn iefc_type(&self) -> &[i32] {
        assert!(!self.raw().iefc_type.is_null(), "Pointer iefc_type is null");
        unsafe { std::slice::from_raw_parts(self.raw().iefc_type, self.nefc()) }
    }

    /// constraint type (mjtConstraint)
    pub fn iefc_type_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().iefc_type.is_null(), "Pointer iefc_type is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_type, self.nefc()) }
    }

    /// id of object of specified type
    pub fn iefc_id(&self) -> &[i32] {
        assert!(!self.raw().iefc_id.is_null(), "Pointer iefc_id is null");
        unsafe { std::slice::from_raw_parts(self.raw().iefc_id, self.nefc()) }
    }

    /// id of object of specified type
    pub fn iefc_id_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().iefc_id.is_null(), "Pointer iefc_id is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_id, self.nefc()) }
    }

    /// number of non-zeros in constraint Jacobian row
    pub fn iefc_J_rownnz(&self) -> &[i32] {
        assert!(
            !self.raw().iefc_J_rownnz.is_null(),
            "Pointer iefc_J_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iefc_J_rownnz, self.nefc()) }
    }

    /// number of non-zeros in constraint Jacobian row
    pub fn iefc_J_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().iefc_J_rownnz.is_null(),
            "Pointer iefc_J_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_J_rownnz, self.nefc()) }
    }

    /// row start address in colind array
    pub fn iefc_J_rowadr(&self) -> &[i32] {
        assert!(
            !self.raw().iefc_J_rowadr.is_null(),
            "Pointer iefc_J_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iefc_J_rowadr, self.nefc()) }
    }

    /// row start address in colind array
    pub fn iefc_J_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().iefc_J_rowadr.is_null(),
            "Pointer iefc_J_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_J_rowadr, self.nefc()) }
    }

    /// number of subsequent rows in supernode
    pub fn iefc_J_rowsuper(&self) -> &[i32] {
        assert!(
            !self.raw().iefc_J_rowsuper.is_null(),
            "Pointer iefc_J_rowsuper is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iefc_J_rowsuper, self.nefc()) }
    }

    /// number of subsequent rows in supernode
    pub fn iefc_J_rowsuper_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().iefc_J_rowsuper.is_null(),
            "Pointer iefc_J_rowsuper is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_J_rowsuper, self.nefc()) }
    }

    /// column indices in constraint Jacobian
    pub fn iefc_J_colind(&self) -> &[i32] {
        assert!(
            !self.raw().iefc_J_colind.is_null(),
            "Pointer iefc_J_colind is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iefc_J_colind, self.nJ()) }
    }

    /// column indices in constraint Jacobian
    pub fn iefc_J_colind_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().iefc_J_colind.is_null(),
            "Pointer iefc_J_colind is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_J_colind, self.nJ()) }
    }

    /// number of non-zeros in constraint Jacobian row T
    pub fn iefc_JT_rownnz(&self) -> &[i32] {
        assert!(
            !self.raw().iefc_JT_rownnz.is_null(),
            "Pointer iefc_JT_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iefc_JT_rownnz, self.nidof()) }
    }

    /// number of non-zeros in constraint Jacobian row T
    pub fn iefc_JT_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().iefc_JT_rownnz.is_null(),
            "Pointer iefc_JT_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_JT_rownnz, self.nidof()) }
    }

    /// row start address in colind array              T
    pub fn iefc_JT_rowadr(&self) -> &[i32] {
        assert!(
            !self.raw().iefc_JT_rowadr.is_null(),
            "Pointer iefc_JT_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iefc_JT_rowadr, self.nidof()) }
    }

    /// row start address in colind array              T
    pub fn iefc_JT_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().iefc_JT_rowadr.is_null(),
            "Pointer iefc_JT_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_JT_rowadr, self.nidof()) }
    }

    /// number of subsequent rows in supernode         T
    pub fn iefc_JT_rowsuper(&self) -> &[i32] {
        assert!(
            !self.raw().iefc_JT_rowsuper.is_null(),
            "Pointer iefc_JT_rowsuper is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iefc_JT_rowsuper, self.nidof()) }
    }

    /// number of subsequent rows in supernode         T
    pub fn iefc_JT_rowsuper_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().iefc_JT_rowsuper.is_null(),
            "Pointer iefc_JT_rowsuper is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_JT_rowsuper, self.nidof()) }
    }

    /// column indices in constraint Jacobian          T
    pub fn iefc_JT_colind(&self) -> &[i32] {
        assert!(
            !self.raw().iefc_JT_colind.is_null(),
            "Pointer iefc_JT_colind is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iefc_JT_colind, self.nJ()) }
    }

    /// column indices in constraint Jacobian          T
    pub fn iefc_JT_colind_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().iefc_JT_colind.is_null(),
            "Pointer iefc_JT_colind is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_JT_colind, self.nJ()) }
    }

    /// constraint Jacobian
    pub fn iefc_J(&self) -> &[mjtNum] {
        assert!(!self.raw().iefc_J.is_null(), "Pointer iefc_J is null");
        unsafe { std::slice::from_raw_parts(self.raw().iefc_J, self.nJ()) }
    }

    /// constraint Jacobian
    pub fn iefc_J_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().iefc_J.is_null(), "Pointer iefc_J is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_J, self.nJ()) }
    }

    /// constraint Jacobian transposed
    pub fn iefc_JT(&self) -> &[mjtNum] {
        assert!(!self.raw().iefc_JT.is_null(), "Pointer iefc_JT is null");
        unsafe { std::slice::from_raw_parts(self.raw().iefc_JT, self.nJ()) }
    }

    /// constraint Jacobian transposed
    pub fn iefc_JT_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().iefc_JT.is_null(), "Pointer iefc_JT is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_JT, self.nJ()) }
    }

    /// frictionloss (friction)
    pub fn iefc_frictionloss(&self) -> &[mjtNum] {
        assert!(
            !self.raw().iefc_frictionloss.is_null(),
            "Pointer iefc_frictionloss is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iefc_frictionloss, self.nefc()) }
    }

    /// frictionloss (friction)
    pub fn iefc_frictionloss_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().iefc_frictionloss.is_null(),
            "Pointer iefc_frictionloss is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_frictionloss, self.nefc()) }
    }

    /// constraint mass
    pub fn iefc_D(&self) -> &[mjtNum] {
        assert!(!self.raw().iefc_D.is_null(), "Pointer iefc_D is null");
        unsafe { std::slice::from_raw_parts(self.raw().iefc_D, self.nefc()) }
    }

    /// constraint mass
    pub fn iefc_D_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().iefc_D.is_null(), "Pointer iefc_D is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_D, self.nefc()) }
    }

    /// inverse constraint mass
    pub fn iefc_R(&self) -> &[mjtNum] {
        assert!(!self.raw().iefc_R.is_null(), "Pointer iefc_R is null");
        unsafe { std::slice::from_raw_parts(self.raw().iefc_R, self.nefc()) }
    }

    /// inverse constraint mass
    pub fn iefc_R_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().iefc_R.is_null(), "Pointer iefc_R is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_R, self.nefc()) }
    }

    /// number of non-zeros in AR
    pub fn efc_AR_rownnz(&self) -> &[i32] {
        assert!(
            !self.raw().efc_AR_rownnz.is_null(),
            "Pointer efc_AR_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_AR_rownnz, self.nefc()) }
    }

    /// number of non-zeros in AR
    pub fn efc_AR_rownnz_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_AR_rownnz.is_null(),
            "Pointer efc_AR_rownnz is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_AR_rownnz, self.nefc()) }
    }

    /// row start address in colind array
    pub fn efc_AR_rowadr(&self) -> &[i32] {
        assert!(
            !self.raw().efc_AR_rowadr.is_null(),
            "Pointer efc_AR_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_AR_rowadr, self.nefc()) }
    }

    /// row start address in colind array
    pub fn efc_AR_rowadr_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_AR_rowadr.is_null(),
            "Pointer efc_AR_rowadr is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_AR_rowadr, self.nefc()) }
    }

    /// column indices in sparse AR
    pub fn efc_AR_colind(&self) -> &[i32] {
        assert!(
            !self.raw().efc_AR_colind.is_null(),
            "Pointer efc_AR_colind is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().efc_AR_colind, self.nA()) }
    }

    /// column indices in sparse AR
    pub fn efc_AR_colind_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().efc_AR_colind.is_null(),
            "Pointer efc_AR_colind is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_AR_colind, self.nA()) }
    }

    /// J*inv(M)*J' + R
    pub fn efc_AR(&self) -> &[mjtNum] {
        assert!(!self.raw().efc_AR.is_null(), "Pointer efc_AR is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_AR, self.nA()) }
    }

    /// J*inv(M)*J' + R
    pub fn efc_AR_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().efc_AR.is_null(), "Pointer efc_AR is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_AR, self.nA()) }
    }

    /// velocity in constraint space: J*qvel
    pub fn efc_vel(&self) -> &[mjtNum] {
        assert!(!self.raw().efc_vel.is_null(), "Pointer efc_vel is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_vel, self.nefc()) }
    }

    /// velocity in constraint space: J*qvel
    pub fn efc_vel_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().efc_vel.is_null(), "Pointer efc_vel is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_vel, self.nefc()) }
    }

    /// reference pseudo-acceleration
    pub fn efc_aref(&self) -> &[mjtNum] {
        assert!(!self.raw().efc_aref.is_null(), "Pointer efc_aref is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_aref, self.nefc()) }
    }

    /// reference pseudo-acceleration
    pub fn efc_aref_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().efc_aref.is_null(), "Pointer efc_aref is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_aref, self.nefc()) }
    }

    /// linear cost term: J*qacc_smooth - aref
    pub fn efc_b(&self) -> &[mjtNum] {
        assert!(!self.raw().efc_b.is_null(), "Pointer efc_b is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_b, self.nefc()) }
    }

    /// linear cost term: J*qacc_smooth - aref
    pub fn efc_b_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().efc_b.is_null(), "Pointer efc_b is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_b, self.nefc()) }
    }

    /// reference pseudo-acceleration
    pub fn iefc_aref(&self) -> &[mjtNum] {
        assert!(!self.raw().iefc_aref.is_null(), "Pointer iefc_aref is null");
        unsafe { std::slice::from_raw_parts(self.raw().iefc_aref, self.nefc()) }
    }

    /// reference pseudo-acceleration
    pub fn iefc_aref_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().iefc_aref.is_null(), "Pointer iefc_aref is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_aref, self.nefc()) }
    }

    /// constraint state (mjtConstraintState)
    pub fn iefc_state(&self) -> &[i32] {
        assert!(
            !self.raw().iefc_state.is_null(),
            "Pointer iefc_state is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iefc_state, self.nefc()) }
    }

    /// constraint state (mjtConstraintState)
    pub fn iefc_state_mut(&mut self) -> &mut [i32] {
        assert!(
            !self.raw().iefc_state.is_null(),
            "Pointer iefc_state is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_state, self.nefc()) }
    }

    /// constraint force in constraint space
    pub fn iefc_force(&self) -> &[mjtNum] {
        assert!(
            !self.raw().iefc_force.is_null(),
            "Pointer iefc_force is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().iefc_force, self.nefc()) }
    }

    /// constraint force in constraint space
    pub fn iefc_force_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().iefc_force.is_null(),
            "Pointer iefc_force is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().iefc_force, self.nefc()) }
    }

    /// constraint state (mjtConstraintState)
    pub fn efc_state(&self) -> &[i32] {
        assert!(!self.raw().efc_state.is_null(), "Pointer efc_state is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_state, self.nefc()) }
    }

    /// constraint state (mjtConstraintState)
    pub fn efc_state_mut(&mut self) -> &mut [i32] {
        assert!(!self.raw().efc_state.is_null(), "Pointer efc_state is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_state, self.nefc()) }
    }

    /// constraint force in constraint space
    pub fn efc_force(&self) -> &[mjtNum] {
        assert!(!self.raw().efc_force.is_null(), "Pointer efc_force is null");
        unsafe { std::slice::from_raw_parts(self.raw().efc_force, self.nefc()) }
    }

    /// constraint force in constraint space
    pub fn efc_force_mut(&mut self) -> &mut [mjtNum] {
        assert!(!self.raw().efc_force.is_null(), "Pointer efc_force is null");
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().efc_force, self.nefc()) }
    }

    /// constraint force
    pub fn ifrc_constraint(&self) -> &[mjtNum] {
        assert!(
            !self.raw().ifrc_constraint.is_null(),
            "Pointer ifrc_constraint is null"
        );
        unsafe { std::slice::from_raw_parts(self.raw().ifrc_constraint, self.nidof()) }
    }

    /// constraint force
    pub fn ifrc_constraint_mut(&mut self) -> &mut [mjtNum] {
        assert!(
            !self.raw().ifrc_constraint.is_null(),
            "Pointer ifrc_constraint is null"
        );
        unsafe { std::slice::from_raw_parts_mut(self.raw_mut().ifrc_constraint, self.nidof()) }
    }
    pub fn threadpool(&self) -> usize {
        self.raw().threadpool as usize
    }
    pub fn signature(&self) -> u64 {
        self.raw().signature as u64
    }
}
