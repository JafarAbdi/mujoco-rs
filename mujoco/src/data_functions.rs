//! Auto-generated Data functions
//! Generated by generate_from_introspect.py - DO NOT EDIT MANUALLY

use crate::Data;

/// Advance simulation, use control callback to obtain external force and control.
pub fn mj_step(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_step(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Advance simulation in two steps: before external force and control is set by user.
pub fn mj_step1(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_step1(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Advance simulation in two steps: after external force and control is set by user.
pub fn mj_step2(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_step2(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Forward dynamics: same as mj_step but do not integrate in time.
pub fn mj_forward(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_forward(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Inverse dynamics: qacc must be set before calling.
pub fn mj_inverse(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_inverse(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Reset data to defaults.
pub fn mj_reset_data(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_resetData(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Run position-dependent computations.
pub fn mj_fwd_position(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_fwdPosition(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Run velocity-dependent computations.
pub fn mj_fwd_velocity(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_fwdVelocity(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Compute actuator force qfrc_actuator.
pub fn mj_fwd_actuation(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_fwdActuation(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Add up all non-constraint forces, compute qacc_smooth.
pub fn mj_fwd_acceleration(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_fwdAcceleration(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Run selected constraint solver.
pub fn mj_fwd_constraint(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_fwdConstraint(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Euler integrator, semi-implicit in velocity.
pub fn mj_euler(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_Euler(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Implicit-in-velocity integrators.
pub fn mj_implicit(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_implicit(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Run position-dependent computations in inverse dynamics.
pub fn mj_inv_position(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_invPosition(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Run velocity-dependent computations in inverse dynamics.
pub fn mj_inv_velocity(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_invVelocity(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Apply the analytical formula for inverse constraint dynamics.
pub fn mj_inv_constraint(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_invConstraint(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Compare forward and inverse dynamics, save results in fwdinv.
pub fn mj_compare_fwd_inv(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_compareFwdInv(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Evaluate position-dependent sensors.
pub fn mj_sensor_pos(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_sensorPos(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Evaluate velocity-dependent sensors.
pub fn mj_sensor_vel(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_sensorVel(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Evaluate acceleration and force-dependent sensors.
pub fn mj_sensor_acc(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_sensorAcc(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Evaluate position-dependent energy (potential).
pub fn mj_energy_pos(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_energyPos(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Evaluate velocity-dependent energy (kinetic).
pub fn mj_energy_vel(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_energyVel(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Check qpos, reset if any element is too big or nan.
pub fn mj_check_pos(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_checkPos(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Check qvel, reset if any element is too big or nan.
pub fn mj_check_vel(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_checkVel(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Check qacc, reset if any element is too big or nan.
pub fn mj_check_acc(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_checkAcc(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Run forward kinematics.
pub fn mj_kinematics(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_kinematics(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Map inertias and motion dofs to global frame centered at CoM.
pub fn mj_com_pos(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_comPos(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Compute camera and light positions and orientations.
pub fn mj_camlight(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_camlight(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Compute flex-related quantities.
pub fn mj_flex(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_flex(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Compute tendon lengths, velocities and moment arms.
pub fn mj_tendon(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_tendon(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Compute actuator transmission lengths and moments.
pub fn mj_transmission(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_transmission(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Run composite rigid body inertia algorithm (CRB).
pub fn mj_crb(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_crb(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Make inertia matrix.
pub fn mj_make_m(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_makeM(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Compute sparse L'*D*L factorizaton of inertia matrix.
pub fn mj_factor_m(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_factorM(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Compute cvel, cdof_dot.
pub fn mj_com_vel(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_comVel(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Compute qfrc_passive from spring-dampers, gravity compensation and fluid forces.
pub fn mj_passive(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_passive(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Sub-tree linear velocity and angular momentum: compute subtree_linvel, subtree_angmom.
pub fn mj_subtree_vel(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_subtreeVel(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// RNE with complete data: compute cacc, cfrc_ext, cfrc_int.
pub fn mj_rne_post_constraint(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_rnePostConstraint(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Run collision detection.
pub fn mj_collision(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_collision(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Construct constraints.
pub fn mj_make_constraint(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_makeConstraint(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Find constraint islands.
pub fn mj_island(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_island(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Compute inverse constraint inertia efc_AR.
pub fn mj_project_constraint(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_projectConstraint(data.model.as_ptr(), data.as_mut_ptr());
    }
}

/// Compute efc_vel, efc_aref.
pub fn mj_reference_constraint(data: &mut Data) {
    unsafe {
        mujoco_sys::mj_referenceConstraint(data.model.as_ptr(), data.as_mut_ptr());
    }
}
